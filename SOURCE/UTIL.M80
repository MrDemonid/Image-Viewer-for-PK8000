$title  ('PRL Externals')
        NAME    UTIL

        CSEG


        public  MON1,MON2,MON3, BOOT


        public SetIRQ
        public RstIRQ
        public SetVec
        public DelVec

        public SelDrv
        public SetDrv
        public SetUsr
        public GetUsr
        public DirRec
        public DoFind
        public NxFind
        public fSize
        public fOpen
        public fClose
        public fRead

;        public utoa
;        public utoh

        public memset
        public memcpy
;        public memcmp

;        public strcpy
        public strlen


; точки входа для функций BDOS
MON1    equ 5h
MON2    equ 5h
MON3    equ 5h
BOOT    equ 0h

; системные переменные
CURDEV  equ 4           ; текущие диск и user
IOBUFF  equ 80h         ; дефолтный буфер DMA
DEFFCB  equ 5Ch         ; дефолтный FCB


INTMGR  equ 0FEDCh      ; адрес менеджера IRQ
INTJMP  equ 0F86Eh      ; переход на пользовательский обработчик прерывания
INTADR  equ 0F86Fh      ; адрес пользовательского обработчика



;
;------------------------------------------------------------------------
; перевод беззнакового числа в строку
;------------------------------------------------------------------------
; на входе:
;    BC         - 16-битное число
; на выходе:
;    HL         - буфер со строкой
;utoa:
;        mov     L, C
;        mov     H, B
;        lxi     D, BufNum
;        mvi     A, '0'          ; флаг пропуска первых нулей
;        lxi     B, -10000
;        call    @@dectoa
;        lxi     B, -1000
;        call    @@dectoa
;        lxi     B, -100
;        call    @@dectoa
;        lxi     B, -10
;        call    @@dectoa
;        mov     A, L
;        ori     '0'
;        stax    D
;        inx     D
;        xra     A
;        stax    D
;        lxi     H, BufNum
;        ret
;  @@dectoa:
;        push    D
;        mov     D, A
;        mvi     A, '0'-1
;    @@decialoop:
;        inr     A
;        dad     B
;        jc      @@decialoop
;        push    PSW
;        mov     A, L
;        sbb     C
;        mov     L, A
;        mov     A, H
;        sbb     B
;        mov     H, A
;        pop     PSW
;        cmp     D
;        pop     D
;        rz
;        stax    D
;        inx     D
;        mvi     A, 0FFh         ; закончили пропуск нулей
;        ret


;------------------------------------------------------------------------
; преобразует байт в hex-строку
;------------------------------------------------------------------------
; на входе:
;    A  - байт
;    DE - буфер
; на выходе:
;    DE - буфер (след. позиция)
;btoh:
;        push    B
;        mov     C, A
;        rlc
;        rlc
;        rlc
;        rlc
;        call    hext
;        mov     A, C
;        call    hext
;        pop     B
;        ret
;hext:
;        ani     0Fh
;        cpi     10
;        jc      @@btoa1
;        adi     7
;    @@btoa1:
;        adi     '0'
;        stax    D
;        inx     D
;        ret


;------------------------------------------------------------------------
; преобразует слово в hex-строку
;------------------------------------------------------------------------
; на входе:
;   BC  - слово
; на выходе:
;    HL - буфер
;utoh:
;        lxi     D, BufNum
;        mov     A, B
;        call    btoh
;        mov     A, C
;        call    btoh
;        xra     A
;        stax    D
;        lxi     H, BufNum
;        ret






;------------------------------------------------------------------------
; заполнение блок памяти символом
;------------------------------------------------------------------------
; на входе:
;    [SP+2] - address memory
;    BC     - count
;    E      - char
; на выходе:
;    HL     - address memory
memset:
        mov     A, E            ; BC - count, A - char
        pop     D
        pop     H               ; HL - address memory
        push    D
        mov     E, A            ; E - char
    @msetl:
        mov     A, C
        ora     B
        rz
        mov     M, E
        inx     H
        dcx     B
        jmp     @msetl


;------------------------------------------------------------------------
; копирование блока памяти
;------------------------------------------------------------------------
; на входе:
;    [SP+2] - source
;    BC     - dest
;    DE     - count
; на выходе:
;    HL     - address memory
memcpy:
        pop     H               ; HL = return address
        xthl                    ; HL - source
    @mcpyl:
        mov     A, E
        ora     D
        rz
        mov     A, M
        stax    B
        inx     H
        inx     B
        dcx     D
        jmp     @mcpyl


;------------------------------------------------------------------------
; сравнение блоков памяти
;------------------------------------------------------------------------
; на входе:
;    [SP+2] - mem1
;    BC     - mem2
;     E     - count
; на выходе:
;                | C Z
;    ------------+----
;    mem2 = mem1 | 0 1
;    mem2 > mem1 | 0 0
;    mem2 < mem1 | 1 0
;    A:
;    mem2 = mem1 | A = 0
;    mem2 > mem1 | A > 0
;    mem2 < mem1 | A < 0
;memcmp:
;        pop     H               ; HL = return address
;        xthl                    ; HL - source
;    @mcmyl:
;        ldax    B
;        sub     M
;        rnz
;        inx     B
;        inx     H
;        dcr     E
;        jnz     @mcmyl
;        ret



;------------------------------------------------------------------------
; копирование строки
;------------------------------------------------------------------------
; на входе:
;    BC     - source
;    DE     - dest
; на выходе:
;    HL     - address memory
;strcpy:
;        xchg                    ; HL - dest
;    @scpyl:
;        ldax    B
;        mov     M, A
;        ora     A
;        rz
;        inx     H
;        inx     B
;        jmp     @scpyl

;------------------------------------------------------------------------
; возвращает длину строки
;------------------------------------------------------------------------
; на входе:
;    BC     - строка
; на выходе:
;    HL     - длина строки
strlen:
        lxi     H, 0
    @slenl:
        ldax    B
        ora     A
        rz
        inx     B
        inx     H
        jmp     @slenl



;*****************************************************************************
;*****************************************************************************
;******************************* SYSTEM FUNCS ********************************
;*****************************************************************************
;*****************************************************************************

;------------------------------------------------------------------------
; выбор диска
;------------------------------------------------------------------------
; на входе:
;    C  - номер диска: 0 - A, 1 - B, и тд.
; на выходе:
;    A  - 0 - диска нет, >0 - диск в наличии
SelDrv:
        call    0DA1Bh
        mov     A, L
        ora     H
        ret



;------------------------------------------------------------------------
; назначение текущего дисковода
;------------------------------------------------------------------------
; на входе:
;    C  - номер дисковода: 0 - A, 1 - B, etc...
SetDrv:
        mov     E, C
        lda     CURDEV
        ani     0F0h            ; сохраняем текущую юзер область
        ora     E
        sta     CURDEV
        mvi     C, 14
        jmp     5

;------------------------------------------------------------------------
; установка user-области
;------------------------------------------------------------------------
; на входе:
;    C  - номер области [0..15]
SetUsr:
        mov     E, C            ; E = UserNo
        mov     A, C
        ral
        ral
        ral
        ral
        ani     0F0h
        mov     C, A
        lda     CURDEV
        mov     B, A
        ani     0F0h
        cmp     C
        rz
        mov     A, B
        ani     0Fh
        ora     C
        sta     CURDEV
        mvi     C, 32
        jmp     5

;------------------------------------------------------------------------
; возвращает номер текущей user-области
;------------------------------------------------------------------------
; на выходе:
;    A  - номер user [0..15]
GetUsr:
        mvi     E, 0FFh
        mvi     C, 32
        jmp     5


;------------------------------------------------------------------------
; поиск первого вхождения файла
;------------------------------------------------------------------------
; на входе:
;    C  - диск (0 - текущий, 1 - A, 2 - B, etc.)
;    DE - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    HL - NULL  - ничего не нашли, иначе адрес на запись о найденном файле
DoFind:
        call    MkFCB
        ; вызываем BDOS
        mvi     C, 17
        call    5
        mov     C, A
        jmp     DirRec

;------------------------------------------------------------------------
; поиск очередного вхождения файла
;------------------------------------------------------------------------
; на выходе:
;    HL - NULL  - ничего не нашли, иначе адрес на запись о найденном файле
NxFind:
        lxi     D, DEFFCB
        mvi     C, 18
        call    5
        mov     C, A

;------------------------------------------------------------------------
; возвращает указатель на запись DIRREC в буфере обмена
;------------------------------------------------------------------------
; на входе:
;    C  - код возврата функцией поиска файлов (номер записи в буфере обмена [0..7])
; на выходе:
;    HL - указатель на запись DIRREC в дефолтном буфере обмена (at 0x0080)
DirRec:
        lxi     H, 0
        mov     A, C
        cpi     0FFh
        rz
        add     A
        add     A
        add     A
        add     A
        add     A
        mov     C, A
        mvi     B, 0
        lxi     H, IOBUFF
        dad     B
        ret

;------------------------------------------------------------------------
; возвращает размер файла
;------------------------------------------------------------------------
; на входе:
;    BC - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    HL - размер файла в записях по 128 байт (0 - если была ошибка или переполнение)
fSize:
        mov     E, C
        mov     D, B
        mvi     C, 0
        call    MkFCB
        ; вызываем BDOS
        push    D
        mvi     C, 35
        call    5
        lxi     H, 0
        pop     D
        lxi     H, 33
        dad     D               ; HL - указатель на размер
        mov     E, M
        inx     H
        mov     D, M
        xchg
        ret


;------------------------------------------------------------------------
; открытие файла
;------------------------------------------------------------------------
; на входе:
;    C  - номер устройства (0 - A, 1 - B, etc.)
;    DE - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    A  - 0xFF: ошибка открытия, иначе успешно
fOpen:
        lda     CURDEV
        ani     0Fh
        cmp     C
        jz      @fofcb
        push    B
        push    D
        call    SetDrv
        pop     D
        pop     B
    @fofcb:
        inr     C
        call    MkFCB
        mvi     C, 15
        jmp     5

;------------------------------------------------------------------------
; закрывает файл
;------------------------------------------------------------------------
; на входе:
;    FCB - открытый файл
fClose:
        lxi     D, DEFFCB
        mvi     C, 16
        jmp     5



;------------------------------------------------------------------------
; чтение файла
;------------------------------------------------------------------------
; на входе:
;    BC - буфер для чтения
;    DE - размер в секторах
; на выходе:
;     A - флаг завершения: 0 - ошибка, -1 - все успешно считалось
fRead:
        mov     A, D
        ora     A
        rnz                     ; ограничим размер файла 255 секторами
        mov     A, E
        ora     A
        rz                      ; -> ошибка
        ; устанавливаем буфер DMA
        mov     E, C
        mov     D, B
        jmp     @frdsd

    @frdlp:
        ; читаем очередной сектор
        lxi     D, DEFFCB
        mvi     C, 20
        call    5
        ora     A
        jnz     @frdqf
        ; переходим к чтению следующего сектора
        pop     PSW
        pop     D               ; DE = bufAddr
        dcr     A
        jz      @frdqo
        lxi     H, 128
        dad     D
        xchg                    ; DE = bufAddr+128
    @frdsd:
        push    D
        push    PSW
        mvi     C, 26
        call    5
        jmp     @frdlp

  @frdqf:
        pop     D               ; очищаем стек
        pop     D
        xra     A
        jmp     @frdxt
  @frdqo:
        ori     -1
  @frdxt:
        push    PSW
        ; восстанавливаем дефолтный буфер DMA
        lxi     D, IOBUFF
        mvi     C, 26
        call    5
        pop     PSW
        ret



;------------------------------------------------------------------------
; заполнение структуры FCB (по дефолтному адресу 0x005C)
;------------------------------------------------------------------------
; на входе:
;    C  - номер устройства (0 - текущий, 1 - A, 2 - B, etc.)
;    DE - имя файла в формат CP/M ('FILENAMEEXT')
; на выходе:
;    DE - указатель на FCB
MkFCB:
        lxi     H, DEFFCB
        push    H
        ; set disk
        mov     M, C
        inx     H
        ; copy file name
        mvi     C, 11
  @fname:
        ldax    D
        inx     D
        mov     M, A
        inx     H
        dcr     C
        jnz     @fname
        ; обнуляем остальные поля
        mvi     C, 36-12
        xra     A
    @fffsz:
        mov     M, A
        inx     H
        dcr     C
        jnz     @fffsz
        pop     D
        ret





;------------------------------------------------------------------------
; Инициализация системы IRQ
;------------------------------------------------------------------------
SetIRQ:
        ; переносим обработчик в верхние адреса
        lxi     D, USRIRQ
        lxi     H, INTMGR
        mvi     C, USREND-USRIRQ
    @sirql:
        ldax    D
        mov     M, A
        inx     D
        inx     H
        dcr     C
        jnz     @sirql
        ; сохраняем старый
        lda     INTJMP
        sta     OLDJMP
        lhld    INTADR
        shld    OLDADR
        ; ставим свой
        di
        mvi     A, 0C3h         ; jmp
        sta     INTJMP
        lxi     H, INTMGR
        shld    INTADR
        ei
        ret

;------------------------------------------------------------------------
; Удаление своей системы IRQ
;------------------------------------------------------------------------
RstIRQ:
        di
        lda     OLDJMP
        sta     INTJMP
        lhld    OLDADR
        shld    INTADR
        ei
        ret

;------------------------------------------------------------------------
; Установка нового вектора прерывания
;------------------------------------------------------------------------
; на входе:
;    BC - адрес нового вектора
;    DE - адрес для сохранения перехода на старый вектор
SetVec:
        di
        ; сохраняем старый вектор
        push    B
        lxi     H, UsrINT
        mvi     C, 3
    @svecs:
        mov     A, M
        stax    D
        inx     H
        inx     D
        dcr     C
        jnz     @svecs
        ; устанавливаем новый
        pop     H
        mvi     A, 0C3h
        sta     UsrINT
        shld    UsrINT+1
        ei
        ret

;------------------------------------------------------------------------
; Удаление последнего вектора
;------------------------------------------------------------------------
; на входе:
;    BC - адрес сохраненного вектора
DelVec:
        di
        lxi     H, UsrINT
        mvi     E, 3
    @dvecr:
        ldax    B
        mov     M, A
        inx     B
        inx     H
        dcr     E
        jnz     @dvecr
        ei
        ret


;------------------------------------------------------------------------
; Менеджер пользовательских прерываний
;------------------------------------------------------------------------
USRIRQ:
        xthl
        pop     H
        push    H
        push    D
        push    B
        push    PSW
        ; делаем доступной всю память
        in      80h
        push    PSW
        mvi     A, 0FFh
        out     80h
        ; вызываем цепочку обработчиков прерывания
        call    UsrINT          ; вызов пользовательских подпрограмм
        pop     PSW
        out     80h
        pop     PSW
        pop     B
        pop     D
        pop     H
        ei
        ret
USREND:

UsrINT:
        ret
        ret
        ret


DSEG
  ; адрес старого обработчика прерывания
  OLDJMP:       ds 1
  OLDADR:       ds 2

  BufNum:       ds 8
END
